import { createRoute, z } from '@hono/zod-openapi';

// Chat completion message schema
const ChatMessageSchema = z.object({
  role: z.enum(['system', 'user', 'assistant', 'tool']).describe('The role of the message author'),
  content: z.string().describe('The content of the message'),
  name: z.string().optional().describe('An optional name for the participant'),
  tool_call_id: z.string().optional().describe('Tool call that this message is responding to')
});

// Chat completion request schema
const ChatCompletionRequestSchema = z.object({
  model: z.string().optional().default('gpt-4o').describe('ID of the model to use'),
  messages: z.array(ChatMessageSchema).min(1).describe('A list of messages comprising the conversation so far'),
  max_tokens: z.number().int().positive().optional().describe('The maximum number of tokens that can be generated in the chat completion'),
  temperature: z.number().min(0).max(2).optional().default(1).describe('What sampling temperature to use, between 0 and 2'),
  top_p: z.number().min(0).max(1).optional().default(1).describe('An alternative to sampling with temperature'),
  n: z.number().int().positive().optional().default(1).describe('How many chat completion choices to generate for each input message'),
  stream: z.boolean().optional().default(false).describe('If set, partial message deltas will be sent'),
  stop: z.union([z.string(), z.array(z.string())]).optional().describe('Up to 4 sequences where the API will stop generating further tokens'),
  presence_penalty: z.number().min(-2).max(2).optional().default(0).describe('Number between -2.0 and 2.0'),
  frequency_penalty: z.number().min(-2).max(2).optional().default(0).describe('Number between -2.0 and 2.0'),
  logit_bias: z.record(z.string(), z.number()).optional().describe('Modify the likelihood of specified tokens appearing in the completion'),
  user: z.string().optional().describe('A unique identifier representing your end-user'),
  thread_id: z.string().optional().describe('Optional thread ID to associate this completion with')
});

// Usage statistics schema
const UsageSchema = z.object({
  prompt_tokens: z.number().int().describe('Number of tokens in the prompt'),
  completion_tokens: z.number().int().describe('Number of tokens in the generated completion'),
  total_tokens: z.number().int().describe('Total number of tokens used in the request')
});

// Chat completion choice schema
const ChatCompletionChoiceSchema = z.object({
  index: z.number().int().describe('The index of the choice in the list of choices'),
  message: ChatMessageSchema.describe('A chat completion message generated by the model'),
  finish_reason: z.enum(['stop', 'length', 'content_filter', 'tool_calls']).nullable().describe('The reason the model stopped generating tokens')
});

// Chat completion response schema
const ChatCompletionResponseSchema = z.object({
  id: z.string().describe('A unique identifier for the chat completion'),
  object: z.literal('chat.completion').describe('The object type, which is always "chat.completion"'),
  created: z.number().int().describe('The Unix timestamp (in seconds) of when the chat completion was created'),
  model: z.string().describe('The model used for the chat completion'),
  choices: z.array(ChatCompletionChoiceSchema).describe('A list of chat completion choices'),
  usage: UsageSchema.optional().describe('Usage statistics for the completion request'),
  system_fingerprint: z.string().optional().describe('This fingerprint represents the backend configuration')
});

// Delta object for streaming
const DeltaSchema = z.object({
  role: z.enum(['system', 'user', 'assistant', 'tool']).optional().describe('The role of the author of this message'),
  content: z.string().optional().describe('The contents of the chunk message')
});

// Streaming choice schema
const StreamingChoiceSchema = z.object({
  index: z.number().int().describe('The index of the choice in the list of choices'),
  delta: DeltaSchema.describe('A chat completion delta generated by streamed model responses'),
  finish_reason: z.enum(['stop', 'length', 'content_filter', 'tool_calls']).nullable().describe('The reason the model stopped generating tokens')
});

// Streaming response schema
const ChatCompletionStreamChunkSchema = z.object({
  id: z.string().describe('A unique identifier for the chat completion'),
  object: z.literal('chat.completion.chunk').describe('The object type, which is always "chat.completion.chunk"'),
  created: z.number().int().describe('The Unix timestamp (in seconds) of when the chat completion was created'),
  model: z.string().describe('The model used for the chat completion'),
  choices: z.array(StreamingChoiceSchema).describe('A list of chat completion choices')
});

// Error response schema
const ErrorResponseSchema = z.object({
  success: z.literal(false),
  error: z.object({
    message: z.string().describe('A human-readable error message'),
    type: z.string().describe('The type of error'),
    code: z.string().optional().describe('An error code, if applicable')
  }),
  metadata: z.object({
    timestamp: z.string().describe('ISO 8601 timestamp'),
    correlation_id: z.string().describe('UUID correlation ID'),
    version: z.string()
  })
});

export const createChatCompletionRoute = createRoute({
  method: 'post',
  path: '/api/v1/chat/completions',
  summary: 'Create Chat Completion',
  description: 'Creates a model response for the given chat conversation. Compatible with OpenAI Chat Completions API.',
  tags: ['Completions'],
  security: [{ bearerAuth: [] }],
  request: {
    body: {
      content: {
        'application/json': {
          schema: ChatCompletionRequestSchema
        }
      },
      description: 'Chat completion request'
    }
  },
  responses: {
    200: {
      description: 'Successful completion response',
      content: {
        'application/json': {
          schema: ChatCompletionResponseSchema
        },
        'text/event-stream': {
          schema: z.object({
            data: ChatCompletionStreamChunkSchema
          }).describe('Server-sent events stream of completion chunks')
        }
      }
    },
    400: {
      description: 'Bad request - Invalid input parameters',
      content: {
        'application/json': {
          schema: ErrorResponseSchema
        }
      }
    },
    401: {
      description: 'Unauthorized - Invalid or missing authentication',
      content: {
        'application/json': {
          schema: ErrorResponseSchema
        }
      }
    },
    429: {
      description: 'Rate limit exceeded',
      content: {
        'application/json': {
          schema: ErrorResponseSchema
        }
      }
    },
    500: {
      description: 'Internal server error',
      content: {
        'application/json': {
          schema: ErrorResponseSchema
        }
      }
    },
    502: {
      description: 'Bad gateway - Error from AI provider',
      content: {
        'application/json': {
          schema: ErrorResponseSchema
        }
      }
    }
  }
});

export const listModelsRoute = createRoute({
  method: 'get',
  path: '/api/v1/models',
  summary: 'List Available Models',
  description: 'Lists the currently available models, and provides basic information about each one such as the owner and availability.',
  tags: ['Completions'],
  security: [{ bearerAuth: [] }],
  responses: {
    200: {
      description: 'List of available models',
      content: {
        'application/json': {
          schema: z.object({
            success: z.literal(true),
            data: z.object({
              object: z.literal('list'),
              data: z.array(z.object({
                id: z.string().describe('The model identifier'),
                object: z.literal('model'),
                created: z.number().int().describe('The Unix timestamp (in seconds) when the model was created'),
                owned_by: z.string().describe('The organization that owns the model'),
                context_length: z.number().int().describe('Maximum context length in tokens'),
                pricing: z.object({
                  input: z.number().describe('Input token price per 1K tokens'),
                  output: z.number().describe('Output token price per 1K tokens')
                }).optional()
              }))
            }),
            metadata: z.object({
              timestamp: z.string().describe('ISO 8601 timestamp'),
              correlation_id: z.string().describe('UUID correlation ID'),
              version: z.string()
            })
          })
        }
      }
    },
    401: {
      description: 'Unauthorized - Invalid or missing authentication',
      content: {
        'application/json': {
          schema: ErrorResponseSchema
        }
      }
    },
    500: {
      description: 'Internal server error',
      content: {
        'application/json': {
          schema: ErrorResponseSchema
        }
      }
    }
  }
});
